<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zelda Soul</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
    </style>
</head>
<body>
    <div id="ui">
        <p id="health">Health: 100</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const screenWidth = 800; // Adjust based on settings.py
        const screenHeight = 600; // Adjust based on settings.py
        const camera = new THREE.OrthographicCamera(0, screenWidth, screenHeight, 0, -1, 1);
        camera.position.z = 1;
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(screenWidth, screenHeight);
        document.body.appendChild(renderer.domElement);

        // Function to load CSV files
        async function loadCSV(url) {
            const response = await fetch(url);
            const text = await response.text();
            return text.split('\n').map(row => row.split(','));
        }

        // Load and render the map
        async function loadMap() {
            const tileSize = 32; // Adjust based on your tile size in Pygame
            const floorData = await loadCSV('map/map_Floor.csv');

            floorData.forEach((row, y) => {
                row.forEach((tile, x) => {
                    if (tile !== '-1' && tile.trim() !== '') { // Assuming '-1' or empty is no tile
                        const texture = new THREE.TextureLoader().load(`graphics/tilemap/${tile}.png`);
                        const material = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(material);
                        sprite.position.set(x * tileSize, y * tileSize, 0);
                        sprite.scale.set(tileSize, tileSize, 1);
                        scene.add(sprite);
                    }
                });
            });
        }
        loadMap();

        class Entity {
            constructor(x, y, spritePath) {
                this.position = new THREE.Vector3(x, y, 0);
                this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: new THREE.TextureLoader().load(spritePath)
                }));
                this.sprite.position.copy(this.position);
                this.sprite.scale.set(32, 32, 1); // Adjust scale based on sprite size
                scene.add(this.sprite);
            }

            updatePosition() {
                this.sprite.position.copy(this.position);
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 'graphics/player/down/0.png');
                this.speed = 5; // Adjust based on original game
            }

            move(dx, dy) {
                this.position.x += dx * this.speed;
                this.position.y += dy * this.speed;
                this.updatePosition();
            }
        }

        // Create player instance
        const player = new Player(100, 100);

        // Input handling
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp': player.move(0, -1); break;
                case 'ArrowDown': player.move(0, 1); break;
                case 'ArrowLeft': player.move(-1, 0); break;
                case 'ArrowRight': player.move(1, 0); break;
            }
        });

        async function getAIActions(creatureData) {
            const response = await fetch('https://api.openai.com/v1/engines/davinci/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' // Replace with your OpenAI API key
                },
                body: JSON.stringify({
                    prompt: `Control creature: ${JSON.stringify(creatureData)}`,
                    max_tokens: 50
                })
            });
            const data = await response.json();
            return data.choices[0].text.trim();
        }

        class Enemy extends Entity {
            constructor(x, y, type) {
                super(x, y, `graphics/monsters/${type}/idle/0.png`);
                this.type = type;
            }

            async update() {
                const action = await getAIActions({ type: this.type, x: this.position.x, y: this.position.y });
                // Example parsing (adjust based on API response format)
                if (action.includes('move')) {
                    this.move(1, 0); // Move right as an example
                }
            }
        }

        const enemy = new Enemy(200, 200, 'bamboo');
        setInterval(() => enemy.update(), 1000); // Update every second

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        async function playSound(url) {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            source.start();
        }

        // Example: Play attack sound on key press
        document.addEventListener('keydown', (event) => {
            if (event.key === ' ') { // Spacebar for attack
                playSound('audio/attack/sound.ogg');
            }
        });

        // Update UI example
        function updateHealth(value) {
            document.getElementById('health').textContent = `Health: ${value}`;
        }
        // Call updateHealth(90) when health changes

        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            // Update game state here
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
